# es6-features

- Деструктуризация
    - Деструктуризация позволяет разбивать объект или массив на переменные при присвоении.

    - Синтаксис: let {prop : varName = default, ...} = object
      Здесь двоеточие : задаёт отображение свойства prop в переменную varName, а равенство =default задаёт выражение,
      которое будет использовано, если значение отсутствует (не указано или undefined).

    - Для массивов имеет значение порядок, поэтому нельзя использовать :, но значение по умолчанию – можно:

    - let [var1 = default, var2, ...rest] = array
      Объявление переменной в начале конструкции не обязательно. Можно использовать и существующие переменные.
      Однако при деструктуризации объекта может потребоваться обернуть выражение в скобки.

    - Вложенные объекты и массивы тоже работают, при деструктуризации нужно лишь сохранить ту же структуру,
      что и исходный объект/массив.

- Функции
    - Можно задавать параметры по умолчанию, а также использовать деструктуризацию для чтения приходящего объекта.
    - Оператор spread (троеточие) в объявлении позволяет функции получать оставшиеся аргументы в массив: function f(arg1, arg2, ...rest).
    - Тот же оператор spread в вызове функции позволяет передать её массив как список аргументов (вместо apply).
    - У функции есть свойство name, оно содержит имя, указанное при объявлении функции, либо, если его нет,
      то имя свойства или переменную, в которую она записана. Есть и некоторые другие ситуации, в которых интерпретатор
      подставляет «самое подходящее» имя.
    - Объявление Function Declaration в блоке {...} видно только в этом блоке.
    - Появились функции-стрелки:
        - Без фигурных скобок возвращают выражение expr: (args) => expr.
        - С фигурными скобками требуют явного return.
        - Не имеют своих this и arguments, при обращении получают их из окружающего контекста.
        - Не могут быть использованы как конструкторы, с new.
- Строки
    - Строки-шаблоны – для удобного задания строк (многострочных, с переменными), плюс возможность использовать
      функцию шаблонизации для самостоятельного форматирования.
    - Юникод – улучшена работа с суррогатными парами.
    - Полезные методы для проверок вхождения одной строки в другую.
- Объекты и прототипы
    - Запись name: name можно заменить на просто name
    - Если имя свойства находится в переменной или задано выражением expr, то его можно указать в квадратных скобках [expr].
    - Свойства-функции можно оформить как методы: "prop: function() {}" → "prop() {}".

    В методах работает обращение к свойствам прототипа через super.parentProperty.

    - Для работы с прототипом:
        - Object.getPrototypeOf(obj) - метод получения прототипа.
        - Object.setPrototypeOf(obj, proto) – метод для установки прототипа.
        - obj.__proto__ – ссылка на прототип.

    - Дополнительно:
        - Метод Object.assign(target, src1, src2...) – копирует свойства из всех аргументов в первый объект.
        - Метод Object.is(value1, value2) проверяет два значения на равенство. В отличие от === считает +0 и -0
          разными числами. А также считает, что NaN равно самому себе.
- Классы
    - Классы можно объявлять как в основном потоке кода, так и «инлайн», по аналогии с Function Declaration и Expression.
    - В объявлении классов можно использовать методы, геттеры/сеттеры и вычислимые названия методов.
    - При наследовании вызов конструктора родителя осуществляется через super(...args),
      вызов родительских методов – через super.method(...args).
- Примитив Symbol
    - Символы – новый примитивный тип, предназначенный для уникальных идентификаторов.
    - Все символы уникальны. Символы с одинаковым именем не равны друг другу.
    - Существует глобальный реестр символов, доступных через метод Symbol.for(name).
      Для глобального символа можно получить имя вызовом и Symbol.keyFor(sym).

      Основная область использования символов – это системные свойства объектов, которые задают разные аспекты их
      поведения. Поддержка у них пока небольшая, но она растёт. Системные символы позволяют разработчикам
      стандарта добавлять новые «особые» свойства объектов, при этом не резервируя соответствующие строковые значения.

      Системные символы доступны как свойства функции Symbol, например Symbol.iterator.

      Мы можем создавать и свои символы, использовать их в объектах. Записывать их как свойства Symbol, разумеется,
      нельзя. Если нужен глобально доступный символ, то используется Symbol.for(имя).
- Итераторы
    - Итератор – объект, предназначенный для перебора другого объекта.
    - У итератора должен быть метод next(), возвращающий объект {done: Boolean, value: any}, где value – очередное
      значение, а done: true в конце.
    - Метод Symbol.iterator предназначен для получения итератора из объекта. Цикл for..of делает это автоматически,
      но можно и вызвать его напрямую.
    - В современном стандарте есть много мест, где вместо массива используются более абстрактные «итерируемые»
      (со свойством Symbol.iterator) объекты, например оператор spread ....
    - Встроенные объекты, такие как массивы и строки, являются итерируемыми, в соответствии с описанным выше.