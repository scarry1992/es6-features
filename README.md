# es6-features

- Деструктуризация
    - Деструктуризация позволяет разбивать объект или массив на переменные при присвоении.

    - Синтаксис: let {prop : varName = default, ...} = object
      Здесь двоеточие : задаёт отображение свойства prop в переменную varName, а равенство =default задаёт выражение,
      которое будет использовано, если значение отсутствует (не указано или undefined).

    - Для массивов имеет значение порядок, поэтому нельзя использовать :, но значение по умолчанию – можно:

    - let [var1 = default, var2, ...rest] = array
      Объявление переменной в начале конструкции не обязательно. Можно использовать и существующие переменные.
      Однако при деструктуризации объекта может потребоваться обернуть выражение в скобки.

    - Вложенные объекты и массивы тоже работают, при деструктуризации нужно лишь сохранить ту же структуру,
      что и исходный объект/массив.

- Функции
    - Можно задавать параметры по умолчанию, а также использовать деструктуризацию для чтения приходящего объекта.
    - Оператор spread (троеточие) в объявлении позволяет функции получать оставшиеся аргументы в массив: function f(arg1, arg2, ...rest).
    - Тот же оператор spread в вызове функции позволяет передать её массив как список аргументов (вместо apply).
    - У функции есть свойство name, оно содержит имя, указанное при объявлении функции, либо, если его нет,
      то имя свойства или переменную, в которую она записана. Есть и некоторые другие ситуации, в которых интерпретатор
      подставляет «самое подходящее» имя.
    - Объявление Function Declaration в блоке {...} видно только в этом блоке.
    - Появились функции-стрелки:
        - Без фигурных скобок возвращают выражение expr: (args) => expr.
        - С фигурными скобками требуют явного return.
        - Не имеют своих this и arguments, при обращении получают их из окружающего контекста.
        - Не могут быть использованы как конструкторы, с new.